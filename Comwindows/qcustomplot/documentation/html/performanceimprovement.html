<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta name="author" content="Emanuel Eichhammer" />
<meta name="copyright" content="(C) 2013-2015 Emanuel Eichhammer" />
<title>Plot Performance Improvement</title>
<link href="qt.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top">
<a class="headerLink"  href="index.html">Main Page</a> &middot;
<a class="headerLink"  href="classoverview.html">Class Overview</a> &middot;
<a class="headerLink"  href="hierarchy.html">Hierarchy</a> &middot;
<a class="headerLink"  href="annotated.html">All Classes</a> &middot;
<a class="headerLink"  href="pages.html">Special Pages</a>
<!-- Generated by Doxygen 1.8.6 -->
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Plot Performance Improvement </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="el" href="classQCustomPlot.html" title="The central class of the library. This is the QWidget which displays the plot and interacts with the ...">QCustomPlot</a> employs various techniques like adaptive sampling and text object caching in order to cut down the time required to replot. However, some features like translucent fills, antialiasing and thick lines can still cause a significant slow down. If you notice this in your application, here are some hints on how to increase replot performance.</p>
<p>By far the most time is spent in the drawing functions, specifically the drawing of high density graphs and other plottables. For maximum performance, consider the following points:</p>
<ul>
<li>Use Qt 4.8.0 and up. Performance has doubled or tripled with respect to Qt 4.7.4. However QPainter was broken and drawing pixel precise things, e.g. scatters, isn't possible with Qt &gt;= 4.8.0. So it's a performance vs. plot quality tradeoff when switching to Qt 4.8. <a class="el" href="classQCustomPlot.html" title="The central class of the library. This is the QWidget which displays the plot and interacts with the ...">QCustomPlot</a> internally tries to work around the worst glitches of this kind.</li>
</ul>
<ul>
<li>To increase responsiveness during range dragging, consider setting <a class="el" href="classQCustomPlot.html#a775bdcb6329d44701aeaa6135b0e5265">QCustomPlot::setNoAntialiasingOnDrag</a> to true.</li>
</ul>
<ul>
<li>On X11 (GNU/Linux), avoid the slow native drawing system, use <em>raster</em> by supplying "-graphicssystem raster" as command line argument or calling QApplication::setGraphicsSystem("raster") before creating the QApplication object. (Only available for Qt versions before 5.0, after that <em>raster</em> is the default engine.)</li>
</ul>
<ul>
<li>On all operating systems, use OpenGL hardware acceleration by supplying "-graphicssystem
opengl" as command line argument or calling QApplication::setGraphicsSystem("opengl") (Only available for Qt versions before 5.0). If OpenGL is available, this will slightly decrease the quality of antialiasing, but extremely increase performance especially with semi-transparent fills, much antialiasing and a large <a class="el" href="classQCustomPlot.html" title="The central class of the library. This is the QWidget which displays the plot and interacts with the ...">QCustomPlot</a> drawing surface. Note however, that the maximum frame rate might be constrained by the vertical sync frequency of your monitor (VSync can be disabled in the graphics card driver configuration). So for simple plots (where the potential framerate is far above 60 frames per second), OpenGL acceleration might achieve numerically lower frame rates than the other graphics systems, because they are not capped at the VSync frequency.</li>
</ul>
<ul>
<li>Avoid any kind of alpha (transparency), especially in fills</li>
</ul>
<ul>
<li>Avoid lines with a pen width greater than one</li>
</ul>
<ul>
<li>Avoid any kind of antialiasing, especially in graph lines (see <a class="el" href="classQCustomPlot.html#ae10d685b5eabea2999fb8775ca173c24">QCustomPlot::setNotAntialiasedElements</a>)</li>
</ul>
<ul>
<li>Avoid repeatedly setting the complete data set with <a class="el" href="classQCPGraph.html#a1df2fd710545c8ba3b2c99a39a27bf8b">QCPGraph::setData</a>. Use <a class="el" href="classQCPGraph.html#aa5c6181d84db72ce4dbe9dc15a34ef4f">QCPGraph::addData</a> instead, if most data points stay unchanged, e.g. in a running measurement. You can access and manipulate existing data via <a class="el" href="classQCPGraph.html#a2f58436df4f86a2792b776a21642b3d9">QCPGraph::data</a>.</li>
</ul>
<ul>
<li>Set the <em>copy</em> parameter of the setData functions to false, so only pointers get transferred. (Relevant only if preparing data maps with a large number of points, i.e. over 10000)</li>
</ul>
<ul>
<li>Try to reduce the number of data points that are in the visible key range at any given moment, e.g. by limiting the maximum key range span (see the <a class="el" href="classQCPAxis.html#a0894084e4c16a1736534c4095746f910">QCPAxis::rangeChanged</a> signal). <a class="el" href="classQCustomPlot.html" title="The central class of the library. This is the QWidget which displays the plot and interacts with the ...">QCustomPlot</a> can optimize away millions of off-screen points very efficiently. </li>
</ul>
</div></div><!-- contents -->
</body>
</html>
